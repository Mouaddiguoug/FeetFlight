{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { hash, compare } from 'bcrypt';\nimport { sign, verify } from 'jsonwebtoken';\nimport { SECRET_KEY } from '@config';\nimport { HttpException } from '@exceptions/HttpException';\nimport { User } from '@interfaces/users.interface';\nimport userModel from '@models/users.model';\nimport { isEmpty } from '@utils/util';\nimport { initializeDbConnection, stripe } from '@/app';\nimport { RolesEnum } from '../enums/RolesEnums';\nimport uid from 'uid';\nimport moment from 'moment';\nimport { transporter } from '@/app';\n\nclass AuthService {\n  public users = userModel;\n\n  public async signup(userData) {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n\n    const signupSession = initializeDbConnection().session({ database: 'neo4j' });\n    const createWalletSession = initializeDbConnection().session({ database: 'neo4j' });\n\n    const email = userData.data.email;\n    try {\n      const findUser = await signupSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length > 0) return { message: `This email ${userData.data.email} already exists` };\n      const hashedPassword = await hash(userData.data.password, 10);\n      if (!userData.data.role || !userData.data.name || !userData.data.userName || !userData.data.password) return { message: 'mlissing data' };\n      switch (userData.data.role) {\n        case RolesEnum.SELLER:\n          if (!userData.data.phone || userData.data.plans.length == 0) return { message: 'data missing' };\n\n          const sellerCustomer = await stripe.customers.create({\n            name: userData.data.name,\n            email: email,\n            balance: 0,\n          });\n\n          const createUserSeller = await signupSession.executeWrite(tx =>\n            tx.run(\n              'create (u:user {id: $userId, name: $name, email: $email, userName: $userName, avatar: \"\", password: $password, createdAt: $createdAt, confirmed: false, verified: false, desactivated: false, phone: $phone, followers: $followers, followings: $followings})-[r: IS_A]->(s:seller {id: $sellerId, verified: $verified}) create (d:deviceToken {token: $token})<-[:logged_in_with]-(u) return u, s',\n              {\n                userId: sellerCustomer.id,\n                followers: 0,\n                followings: 0,\n                buyerId: uid.uid(40),\n                token: userData.data.deviceToken,\n                createdAt: moment().format('MMMM DD, YYYY'),\n                email: email,\n                userName: userData.data.userName,\n                name: userData.data.name,\n                password: hashedPassword,\n                sellerId: uid.uid(40),\n                verified: false,\n                phone: userData.data.phone,\n              },\n            ),\n          );\n\n          await createWalletSession.executeWrite(tx =>\n            tx.run('match (s:seller {id: $sellerId}) create (s)-[:HAS_A]->(:wallet {id: $walletId, amount: 0.0})', {\n              sellerId: createUserSeller.records.map(record => record.get('s').properties.id)[0],\n              walletId: uid.uid(40),\n            }),\n          );\n\n          userData.data.plans.map(async (plan: any) => {\n            const createPlansSession = initializeDbConnection().session({ database: 'neo4j' });\n            try {\n              const stripeCreatedPlan = await stripe.products.create({\n                name: plan.name,\n              });\n              const stripeCreatedPrice = await stripe.prices.create({\n                currency: \"EUR\",\n                product: stripeCreatedPlan.id,\n                recurring: {\n                  interval: \"month\",\n                  interval_count: 1,\n                },\n                unit_amount: plan.price * 100\n              });\n\n              await createPlansSession.executeWrite(tx =>\n                tx.run('match (s:seller {id: $sellerId}) create (s)-[:HAS_A]->(:plan {id: $planId, name: $name, price: $price})', {\n                  sellerId: createUserSeller.records.map(record => record.get('s').properties.id)[0],\n                  planId: stripeCreatedPrice.id,\n                  name: plan.name,\n                  price: plan.price,\n                }),\n              );\n            } catch (error) {\n              console.log(error);\n            } finally {\n              createPlansSession.close();\n            }\n          });\n\n          const sellerToken = this.createToken(process.env.EMAIL_SECRET, createUserSeller.records.map(record => record.get('u').properties.id)[0]);\n\n          this.sendVerificationEmail(email, userData.data.userName, sellerToken.token, 'selling');\n          return { tokenData: sellerToken, data: createUserSeller.records.map(record => record.get('u').properties)[0], role: RolesEnum.SELLER };\n          break;\n        case RolesEnum.BUYER:\n          const buyer = await stripe.customers.create({\n            name: userData.data.name,\n            email: email,\n            balance: 0,\n          });\n\n          const createdUserBuyer = await signupSession.executeWrite(tx =>\n            tx.run(\n              'create (u:user {id: $userId, avatar: \"\", name: $name, email: $email, userName: $userName, password: $password, createdAt: $createdAt, confirmed: false})-[r: IS_A]->(b:buyer {id: $buyerId}) create (d:deviceToken {token: $token})<-[:logged_in_with]-(u) return u',\n              {\n                userId: buyer.id,\n                buyerId: uid.uid(40),\n                token: userData.data.deviceToken,\n                createdAt: moment().format('MMMM DD, YYYY'),\n                email: email,\n                userName: userData.data.userName,\n                name: userData.data.name,\n                password: hashedPassword,\n              },\n            ),\n          );\n\n          const buyerToken = this.createToken(process.env.EMAIL_SECRET, createdUserBuyer.records.map(record => record.get('u').properties.id)[0]);\n          this.sendVerificationEmail(email, userData.data.userName, buyerToken.token, 'finding');\n\n          return { tokenData: buyerToken, data: createdUserBuyer.records.map(record => record.get('u').properties)[0], role: RolesEnum.BUYER };\n          break;\n      }\n    } catch (error) {\n      console.log(error);\n    } finally {\n      await signupSession.close();\n      await createWalletSession.close();\n    }\n  }\n\n  public async sendVerificationEmail(email: string, userName: string, token: string, role: string) {\n    try {\n      const mailOptions = {\n        template: 'verifying_email',\n        from: process.env.USER_EMAIL,\n        to: email,\n        subject: 'Verifying Email',\n        context: {\n          userName: userName,\n          token: token,\n          domain: process.env.DOMAIN,\n          role: role,\n        },\n      };\n\n      transporter.sendMail(mailOptions, (error: any, data: any) => {\n        if (error) console.log(error);\n        if (!error) console.log('sent');\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public async resendVerificationEmail(email: string) {\n    const getUserByEmailSession = initializeDbConnection().session();\n    const checkForRoleSession = initializeDbConnection().session();\n    try {\n      const user = await getUserByEmailSession.executeRead(tx => tx.run(\"match (u:user {email: $email}) return u\", {\n        email: email\n      }));\n\n      const role = await checkForRoleSession.executeRead(tx => tx.run(\"match (user:user {email: $email}), (s:seller) with true as isSeller where exists((user)-[:IS_A]->(s)) return isSeller\", {\n        email: email\n      }));\n\n      console.log(role.records.map(record => record.get('isSeller')));\n\n      const tokenData = this.createToken(process.env.EMAIL_SECRET, user.records.map(record => record.get('u').properties.id)[0])\n\n      const mailOptions = {\n        template: 'verifying_email',\n        from: process.env.USER_EMAIL,\n        to: email,\n        subject: 'Verifying Email',\n        context: {\n          userName: user.records.map(record => record.get('u').properties.userName)[0],\n          token: tokenData.token,\n          domain: process.env.DOMAIN,\n          role: role.records.map(record => record.get('isSeller')).length > 0 ? \"Seller\" : \"Buyer\",\n        },\n      };\n\n      transporter.sendMail(mailOptions, (error: any, data: any) => {\n        if (error) console.log(error);\n        if (!error) console.log('sent');\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public async changePassword(email: String, userData: any) {\n    const checkUserSession = initializeDbConnection().session();\n    const changePasswordSession = initializeDbConnection().session();\n    try {\n\n      const findUser = await checkUserSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length == 0) return { message: `old password is incorrect` };\n\n      const password = findUser.records.map(record => record.get('u').properties.password)[0];\n      const isPasswordMatching = await compare(userData.data.oldPassword, password);\n      if (!isPasswordMatching) return { message: 'old password is incorrect' };\n      const hashedPassword = await hash(userData.data.newPassword, 10);\n      const changedPassword = await changePasswordSession.executeWrite(tx =>\n        tx.run('match (u {email: $email}) set u.password = $newPassword return u', {\n          email: email,\n          newPassword: hashedPassword,\n        }),\n      );\n\n      return changedPassword.records.map(record => record.get('u').properties)[0];\n    } catch (error) {\n      console.log(error);\n    } finally {\n      changePasswordSession.close();\n    }\n  }\n\n  public async login(userData) {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n    const loginSession = initializeDbConnection().session({ database: 'neo4j' });\n\n    try {\n      const email = userData.data.email;\n\n      const findUser = await loginSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length == 0) return { message: `password or email is incorrect` };\n\n      const password = findUser.records.map(record => record.get('u').properties.password)[0];\n      const isPasswordMatching = await compare(userData.data.password, password);\n      const userId = findUser.records.map(record => record.get('u').properties.id)[0];\n      const deviceToken = userData.data.deviceToken;\n\n      if (!isPasswordMatching) return { message: 'password or email is incorrect' };\n\n      const tokenData = this.createToken(\n        process.env.SECRET_KEY,\n        userId,\n      );\n\n      const role = await loginSession.executeRead(tx =>\n        tx.run('match (u:user {id: $id})-[:IS_A]-(r:seller) return r', { id: userId }),\n      );\n\n      await loginSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $id})-[:logged_in_with]->(d:deviceToken) set d.token = $token', { id: userId, token: deviceToken }),\n      );\n\n      return { tokenData, data: findUser.records.map(record => record.get('u').properties)[0], role: role.records.length == 0 ? 'Buyer' : 'Seller' };\n    } catch (error) {\n      console.log(error);\n    } finally {\n      loginSession.close();\n    }\n  }\n\n\n  public async refreshToken(id: string) {\n\n    if (!id) return { message: 'missing token' };\n    const refreshSession = initializeDbConnection().session({ database: 'neo4j' });\n    try {\n      const tokenData = this.createRefreshToken(id);\n\n      return { tokenData };\n    } catch (error) {\n      console.log(error);\n    } finally {\n      refreshSession.close();\n    }\n  }\n\n  public async logout(userData: User): Promise<User> {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n\n    const findUser: User = this.users.find(user => user.email === userData.email && user.password === userData.password);\n    if (!findUser) throw new HttpException(409, \"User doesn't exist\");\n\n    return findUser;\n  }\n\n  public createToken(secret: string, data: any) {\n    try {\n      const dataStoredInToken = { id: data };\n      const secretKey: string = secret;\n      const expiresAt: string = '280s';\n      const expiresIn: Date = new Date();\n      console.log(expiresIn);\n      expiresIn.setTime(expiresIn.getTime() + 60000);\n\n      console.log(expiresIn);\n\n\n      return { token: sign(dataStoredInToken, secretKey, { expiresIn: expiresAt }), expiresIn: moment(expiresIn).format(\"YYYY-MM-DD HH:mm:ss.ms\") };\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public createRefreshToken(data) {\n    try {\n      const dataStoredInToken = { id: data, refresh: true };\n\n      const secretKey: string = SECRET_KEY;\n      const expiresAt: string = '30d';\n      const expiresIn: Date = new Date();\n      expiresIn.setTime(expiresIn.getTime() + 60);\n\n      return { token: sign(dataStoredInToken, secretKey, { expiresIn: expiresAt }), expiresIn: moment(expiresIn).format(\"YYYY-MM-DD hh:mm:ss.ms\") };\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public createCookie(tokenData): string {\n    return `Authorization=${tokenData.token}; HttpOnly; Max-Age=${tokenData.expiresIn};`;\n  }\n}\n\nexport default AuthService;\n"],"names":["AuthService","signup","userData","isEmpty","HttpException","signupSession","initializeDbConnection","session","database","createWalletSession","email","data","findUser","executeRead","tx","run","records","length","message","hashedPassword","hash","password","role","name","userName","RolesEnum","SELLER","phone","plans","sellerCustomer","stripe","customers","create","balance","createUserSeller","executeWrite","userId","id","followers","followings","buyerId","uid","token","deviceToken","createdAt","moment","format","sellerId","verified","map","record","get","properties","walletId","plan","createPlansSession","stripeCreatedPlan","products","stripeCreatedPrice","prices","currency","product","recurring","interval","interval_count","unit_amount","price","planId","error","console","log","close","sellerToken","createToken","process","env","EMAIL_SECRET","sendVerificationEmail","tokenData","BUYER","buyer","createdUserBuyer","buyerToken","mailOptions","template","from","USER_EMAIL","to","subject","context","domain","DOMAIN","transporter","sendMail","resendVerificationEmail","getUserByEmailSession","checkForRoleSession","user","changePassword","checkUserSession","changePasswordSession","isPasswordMatching","compare","oldPassword","newPassword","changedPassword","login","loginSession","SECRET_KEY","refreshToken","refreshSession","createRefreshToken","logout","users","find","secret","dataStoredInToken","secretKey","expiresAt","expiresIn","Date","setTime","getTime","sign","refresh","createCookie","userModel"],"mappings":";;;;+BAyUA;;;eAAA;;;wBAzU8B;8BACD;wBACF;+BACG;mEAER;sBACE;qBACuB;4BACrB;4DACV;+DACG;;;;;;;;;;;;;;;;;;;AAGnB,IAAA,AAAMA,cAAN,MAAMA;IAGJ,MAAaC,OAAOC,QAAQ,EAAE;QAC5B,IAAIC,IAAAA,aAAO,EAACD,WAAW,MAAM,IAAIE,4BAAa,CAAC,KAAK;QAEpD,MAAMC,gBAAgBC,IAAAA,2BAAsB,IAAGC,OAAO,CAAC;YAAEC,UAAU;QAAQ;QAC3E,MAAMC,sBAAsBH,IAAAA,2BAAsB,IAAGC,OAAO,CAAC;YAAEC,UAAU;QAAQ;QAEjF,MAAME,QAAQR,SAASS,IAAI,CAACD,KAAK;QACjC,IAAI;YACF,MAAME,WAAW,MAAMP,cAAcQ,WAAW,CAACC,CAAAA,KAAMA,GAAGC,GAAG,CAAC,2CAA2C;oBAAEL,OAAOA;gBAAM;YACxH,IAAIE,SAASI,OAAO,CAACC,MAAM,GAAG,GAAG,OAAO;gBAAEC,SAAS,CAAC,WAAW,EAAEhB,SAASS,IAAI,CAACD,KAAK,CAAC,eAAe,CAAC;YAAC;YACtG,MAAMS,iBAAiB,MAAMC,IAAAA,YAAI,EAAClB,SAASS,IAAI,CAACU,QAAQ,EAAE;YAC1D,IAAI,CAACnB,SAASS,IAAI,CAACW,IAAI,IAAI,CAACpB,SAASS,IAAI,CAACY,IAAI,IAAI,CAACrB,SAASS,IAAI,CAACa,QAAQ,IAAI,CAACtB,SAASS,IAAI,CAACU,QAAQ,EAAE,OAAO;gBAAEH,SAAS;YAAgB;YACxI,OAAQhB,SAASS,IAAI,CAACW,IAAI;gBACxB,KAAKG,qBAAS,CAACC,MAAM;oBACnB,IAAI,CAACxB,SAASS,IAAI,CAACgB,KAAK,IAAIzB,SAASS,IAAI,CAACiB,KAAK,CAACX,MAAM,IAAI,GAAG,OAAO;wBAAEC,SAAS;oBAAe;oBAE9F,MAAMW,iBAAiB,MAAMC,WAAM,CAACC,SAAS,CAACC,MAAM,CAAC;wBACnDT,MAAMrB,SAASS,IAAI,CAACY,IAAI;wBACxBb,OAAOA;wBACPuB,SAAS;oBACX;oBAEA,MAAMC,mBAAmB,MAAM7B,cAAc8B,YAAY,CAACrB,CAAAA,KACxDA,GAAGC,GAAG,CACJ,sYACA;4BACEqB,QAAQP,eAAeQ,EAAE;4BACzBC,WAAW;4BACXC,YAAY;4BACZC,SAASC,YAAG,CAACA,GAAG,CAAC;4BACjBC,OAAOxC,SAASS,IAAI,CAACgC,WAAW;4BAChCC,WAAWC,IAAAA,eAAM,IAAGC,MAAM,CAAC;4BAC3BpC,OAAOA;4BACPc,UAAUtB,SAASS,IAAI,CAACa,QAAQ;4BAChCD,MAAMrB,SAASS,IAAI,CAACY,IAAI;4BACxBF,UAAUF;4BACV4B,UAAUN,YAAG,CAACA,GAAG,CAAC;4BAClBO,UAAU;4BACVrB,OAAOzB,SAASS,IAAI,CAACgB,KAAK;wBAC5B;oBAIJ,MAAMlB,oBAAoB0B,YAAY,CAACrB,CAAAA,KACrCA,GAAGC,GAAG,CAAC,gGAAgG;4BACrGgC,UAAUb,iBAAiBlB,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACf,EAAE,CAAC,CAAC,EAAE;4BAClFgB,UAAUZ,YAAG,CAACA,GAAG,CAAC;wBACpB;oBAGFvC,SAASS,IAAI,CAACiB,KAAK,CAACqB,GAAG,CAAC,OAAOK;wBAC7B,MAAMC,qBAAqBjD,IAAAA,2BAAsB,IAAGC,OAAO,CAAC;4BAAEC,UAAU;wBAAQ;wBAChF,IAAI;4BACF,MAAMgD,oBAAoB,MAAM1B,WAAM,CAAC2B,QAAQ,CAACzB,MAAM,CAAC;gCACrDT,MAAM+B,KAAK/B,IAAI;4BACjB;4BACA,MAAMmC,qBAAqB,MAAM5B,WAAM,CAAC6B,MAAM,CAAC3B,MAAM,CAAC;gCACpD4B,UAAU;gCACVC,SAASL,kBAAkBnB,EAAE;gCAC7ByB,WAAW;oCACTC,UAAU;oCACVC,gBAAgB;gCAClB;gCACAC,aAAaX,KAAKY,KAAK,GAAG;4BAC5B;4BAEA,MAAMX,mBAAmBpB,YAAY,CAACrB,CAAAA,KACpCA,GAAGC,GAAG,CAAC,2GAA2G;oCAChHgC,UAAUb,iBAAiBlB,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACf,EAAE,CAAC,CAAC,EAAE;oCAClF8B,QAAQT,mBAAmBrB,EAAE;oCAC7Bd,MAAM+B,KAAK/B,IAAI;oCACf2C,OAAOZ,KAAKY,KAAK;gCACnB;wBAEJ,EAAE,OAAOE,OAAO;4BACdC,QAAQC,GAAG,CAACF;wBACd,SAAU;4BACRb,mBAAmBgB,KAAK;wBAC1B;oBACF;oBAEA,MAAMC,cAAc,IAAI,CAACC,WAAW,CAACC,QAAQC,GAAG,CAACC,YAAY,EAAE1C,iBAAiBlB,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACf,EAAE,CAAC,CAAC,EAAE;oBAEvI,IAAI,CAACwC,qBAAqB,CAACnE,OAAOR,SAASS,IAAI,CAACa,QAAQ,EAAEgD,YAAY9B,KAAK,EAAE;oBAC7E,OAAO;wBAAEoC,WAAWN;wBAAa7D,MAAMuB,iBAAiBlB,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC,CAAC,EAAE;wBAAE9B,MAAMG,qBAAS,CAACC,MAAM;oBAAC;oBACrI;gBACF,KAAKD,qBAAS,CAACsD,KAAK;oBAClB,MAAMC,QAAQ,MAAMlD,WAAM,CAACC,SAAS,CAACC,MAAM,CAAC;wBAC1CT,MAAMrB,SAASS,IAAI,CAACY,IAAI;wBACxBb,OAAOA;wBACPuB,SAAS;oBACX;oBAEA,MAAMgD,mBAAmB,MAAM5E,cAAc8B,YAAY,CAACrB,CAAAA,KACxDA,GAAGC,GAAG,CACJ,uQACA;4BACEqB,QAAQ4C,MAAM3C,EAAE;4BAChBG,SAASC,YAAG,CAACA,GAAG,CAAC;4BACjBC,OAAOxC,SAASS,IAAI,CAACgC,WAAW;4BAChCC,WAAWC,IAAAA,eAAM,IAAGC,MAAM,CAAC;4BAC3BpC,OAAOA;4BACPc,UAAUtB,SAASS,IAAI,CAACa,QAAQ;4BAChCD,MAAMrB,SAASS,IAAI,CAACY,IAAI;4BACxBF,UAAUF;wBACZ;oBAIJ,MAAM+D,aAAa,IAAI,CAACT,WAAW,CAACC,QAAQC,GAAG,CAACC,YAAY,EAAEK,iBAAiBjE,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACf,EAAE,CAAC,CAAC,EAAE;oBACtI,IAAI,CAACwC,qBAAqB,CAACnE,OAAOR,SAASS,IAAI,CAACa,QAAQ,EAAE0D,WAAWxC,KAAK,EAAE;oBAE5E,OAAO;wBAAEoC,WAAWI;wBAAYvE,MAAMsE,iBAAiBjE,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC,CAAC,EAAE;wBAAE9B,MAAMG,qBAAS,CAACsD,KAAK;oBAAC;oBACnI;YACJ;QACF,EAAE,OAAOX,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACR,MAAM/D,cAAckE,KAAK;YACzB,MAAM9D,oBAAoB8D,KAAK;QACjC;IACF;IAEA,MAAaM,sBAAsBnE,KAAa,EAAEc,QAAgB,EAAEkB,KAAa,EAAEpB,IAAY,EAAE;QAC/F,IAAI;YACF,MAAM6D,cAAc;gBAClBC,UAAU;gBACVC,MAAMX,QAAQC,GAAG,CAACW,UAAU;gBAC5BC,IAAI7E;gBACJ8E,SAAS;gBACTC,SAAS;oBACPjE,UAAUA;oBACVkB,OAAOA;oBACPgD,QAAQhB,QAAQC,GAAG,CAACgB,MAAM;oBAC1BrE,MAAMA;gBACR;YACF;YAEAsE,gBAAW,CAACC,QAAQ,CAACV,aAAa,CAACf,OAAYzD;gBAC7C,IAAIyD,OAAOC,QAAQC,GAAG,CAACF;gBACvB,IAAI,CAACA,OAAOC,QAAQC,GAAG,CAAC;YAC1B;QACF,EAAE,OAAOF,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd;IACF;IAEA,MAAa0B,wBAAwBpF,KAAa,EAAE;QAClD,MAAMqF,wBAAwBzF,IAAAA,2BAAsB,IAAGC,OAAO;QAC9D,MAAMyF,sBAAsB1F,IAAAA,2BAAsB,IAAGC,OAAO;QAC5D,IAAI;YACF,MAAM0F,OAAO,MAAMF,sBAAsBlF,WAAW,CAACC,CAAAA,KAAMA,GAAGC,GAAG,CAAC,2CAA2C;oBAC3GL,OAAOA;gBACT;YAEA,MAAMY,OAAO,MAAM0E,oBAAoBnF,WAAW,CAACC,CAAAA,KAAMA,GAAGC,GAAG,CAAC,yHAAyH;oBACvLL,OAAOA;gBACT;YAEA2D,QAAQC,GAAG,CAAChD,KAAKN,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC;YAElD,MAAM2B,YAAY,IAAI,CAACL,WAAW,CAACC,QAAQC,GAAG,CAACC,YAAY,EAAEqB,KAAKjF,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACf,EAAE,CAAC,CAAC,EAAE;YAEzH,MAAM8C,cAAc;gBAClBC,UAAU;gBACVC,MAAMX,QAAQC,GAAG,CAACW,UAAU;gBAC5BC,IAAI7E;gBACJ8E,SAAS;gBACTC,SAAS;oBACPjE,UAAUyE,KAAKjF,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC5B,QAAQ,CAAC,CAAC,EAAE;oBAC5EkB,OAAOoC,UAAUpC,KAAK;oBACtBgD,QAAQhB,QAAQC,GAAG,CAACgB,MAAM;oBAC1BrE,MAAMA,KAAKN,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,aAAalC,MAAM,GAAG,IAAI,WAAW;gBACnF;YACF;YAEA2E,gBAAW,CAACC,QAAQ,CAACV,aAAa,CAACf,OAAYzD;gBAC7C,IAAIyD,OAAOC,QAAQC,GAAG,CAACF;gBACvB,IAAI,CAACA,OAAOC,QAAQC,GAAG,CAAC;YAC1B;QACF,EAAE,OAAOF,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd;IACF;IAEA,MAAa8B,eAAexF,KAAa,EAAER,QAAa,EAAE;QACxD,MAAMiG,mBAAmB7F,IAAAA,2BAAsB,IAAGC,OAAO;QACzD,MAAM6F,wBAAwB9F,IAAAA,2BAAsB,IAAGC,OAAO;QAC9D,IAAI;YAEF,MAAMK,WAAW,MAAMuF,iBAAiBtF,WAAW,CAACC,CAAAA,KAAMA,GAAGC,GAAG,CAAC,2CAA2C;oBAAEL,OAAOA;gBAAM;YAC3H,IAAIE,SAASI,OAAO,CAACC,MAAM,IAAI,GAAG,OAAO;gBAAEC,SAAS,CAAC,yBAAyB,CAAC;YAAC;YAEhF,MAAMG,WAAWT,SAASI,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC/B,QAAQ,CAAC,CAAC,EAAE;YACvF,MAAMgF,qBAAqB,MAAMC,IAAAA,eAAO,EAACpG,SAASS,IAAI,CAAC4F,WAAW,EAAElF;YACpE,IAAI,CAACgF,oBAAoB,OAAO;gBAAEnF,SAAS;YAA4B;YACvE,MAAMC,iBAAiB,MAAMC,IAAAA,YAAI,EAAClB,SAASS,IAAI,CAAC6F,WAAW,EAAE;YAC7D,MAAMC,kBAAkB,MAAML,sBAAsBjE,YAAY,CAACrB,CAAAA,KAC/DA,GAAGC,GAAG,CAAC,oEAAoE;oBACzEL,OAAOA;oBACP8F,aAAarF;gBACf;YAGF,OAAOsF,gBAAgBzF,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC,CAAC,EAAE;QAC7E,EAAE,OAAOgB,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACRgC,sBAAsB7B,KAAK;QAC7B;IACF;IAEA,MAAamC,MAAMxG,QAAQ,EAAE;QAC3B,IAAIC,IAAAA,aAAO,EAACD,WAAW,MAAM,IAAIE,4BAAa,CAAC,KAAK;QACpD,MAAMuG,eAAerG,IAAAA,2BAAsB,IAAGC,OAAO,CAAC;YAAEC,UAAU;QAAQ;QAE1E,IAAI;YACF,MAAME,QAAQR,SAASS,IAAI,CAACD,KAAK;YAEjC,MAAME,WAAW,MAAM+F,aAAa9F,WAAW,CAACC,CAAAA,KAAMA,GAAGC,GAAG,CAAC,2CAA2C;oBAAEL,OAAOA;gBAAM;YACvH,IAAIE,SAASI,OAAO,CAACC,MAAM,IAAI,GAAG,OAAO;gBAAEC,SAAS,CAAC,8BAA8B,CAAC;YAAC;YAErF,MAAMG,WAAWT,SAASI,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC/B,QAAQ,CAAC,CAAC,EAAE;YACvF,MAAMgF,qBAAqB,MAAMC,IAAAA,eAAO,EAACpG,SAASS,IAAI,CAACU,QAAQ,EAAEA;YACjE,MAAMe,SAASxB,SAASI,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACf,EAAE,CAAC,CAAC,EAAE;YAC/E,MAAMM,cAAczC,SAASS,IAAI,CAACgC,WAAW;YAE7C,IAAI,CAAC0D,oBAAoB,OAAO;gBAAEnF,SAAS;YAAiC;YAE5E,MAAM4D,YAAY,IAAI,CAACL,WAAW,CAChCC,QAAQC,GAAG,CAACiC,UAAU,EACtBxE;YAGF,MAAMd,OAAO,MAAMqF,aAAa9F,WAAW,CAACC,CAAAA,KAC1CA,GAAGC,GAAG,CAAC,wDAAwD;oBAAEsB,IAAID;gBAAO;YAG9E,MAAMuE,aAAaxE,YAAY,CAACrB,CAAAA,KAC9BA,GAAGC,GAAG,CAAC,oFAAoF;oBAAEsB,IAAID;oBAAQM,OAAOC;gBAAY;YAG9H,OAAO;gBAAEmC;gBAAWnE,MAAMC,SAASI,OAAO,CAACiC,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC,CAAC,EAAE;gBAAE9B,MAAMA,KAAKN,OAAO,CAACC,MAAM,IAAI,IAAI,UAAU;YAAS;QAC/I,EAAE,OAAOmD,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACRuC,aAAapC,KAAK;QACpB;IACF;IAGA,MAAasC,aAAaxE,EAAU,EAAE;QAEpC,IAAI,CAACA,IAAI,OAAO;YAAEnB,SAAS;QAAgB;QAC3C,MAAM4F,iBAAiBxG,IAAAA,2BAAsB,IAAGC,OAAO,CAAC;YAAEC,UAAU;QAAQ;QAC5E,IAAI;YACF,MAAMsE,YAAY,IAAI,CAACiC,kBAAkB,CAAC1E;YAE1C,OAAO;gBAAEyC;YAAU;QACrB,EAAE,OAAOV,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACR0C,eAAevC,KAAK;QACtB;IACF;IAEA,MAAayC,OAAO9G,QAAc,EAAiB;QACjD,IAAIC,IAAAA,aAAO,EAACD,WAAW,MAAM,IAAIE,4BAAa,CAAC,KAAK;QAEpD,MAAMQ,WAAiB,IAAI,CAACqG,KAAK,CAACC,IAAI,CAACjB,CAAAA,OAAQA,KAAKvF,KAAK,KAAKR,SAASQ,KAAK,IAAIuF,KAAK5E,QAAQ,KAAKnB,SAASmB,QAAQ;QACnH,IAAI,CAACT,UAAU,MAAM,IAAIR,4BAAa,CAAC,KAAK;QAE5C,OAAOQ;IACT;IAEO6D,YAAY0C,MAAc,EAAExG,IAAS,EAAE;QAC5C,IAAI;YACF,MAAMyG,oBAAoB;gBAAE/E,IAAI1B;YAAK;YACrC,MAAM0G,YAAoBF;YAC1B,MAAMG,YAAoB;YAC1B,MAAMC,YAAkB,IAAIC;YAC5BnD,QAAQC,GAAG,CAACiD;YACZA,UAAUE,OAAO,CAACF,UAAUG,OAAO,KAAK;YAExCrD,QAAQC,GAAG,CAACiD;YAGZ,OAAO;gBAAE7E,OAAOiF,IAAAA,kBAAI,EAACP,mBAAmBC,WAAW;oBAAEE,WAAWD;gBAAU;gBAAIC,WAAW1E,IAAAA,eAAM,EAAC0E,WAAWzE,MAAM,CAAC;YAA0B;QAC9I,EAAE,OAAOsB,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd;IACF;IAEO2C,mBAAmBpG,IAAI,EAAE;QAC9B,IAAI;YACF,MAAMyG,oBAAoB;gBAAE/E,IAAI1B;gBAAMiH,SAAS;YAAK;YAEpD,MAAMP,YAAoBT,kBAAU;YACpC,MAAMU,YAAoB;YAC1B,MAAMC,YAAkB,IAAIC;YAC5BD,UAAUE,OAAO,CAACF,UAAUG,OAAO,KAAK;YAExC,OAAO;gBAAEhF,OAAOiF,IAAAA,kBAAI,EAACP,mBAAmBC,WAAW;oBAAEE,WAAWD;gBAAU;gBAAIC,WAAW1E,IAAAA,eAAM,EAAC0E,WAAWzE,MAAM,CAAC;YAA0B;QAC9I,EAAE,OAAOsB,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd;IACF;IAEOyD,aAAa/C,SAAS,EAAU;QACrC,OAAO,CAAC,cAAc,EAAEA,UAAUpC,KAAK,CAAC,oBAAoB,EAAEoC,UAAUyC,SAAS,CAAC,CAAC,CAAC;IACtF;;QAxTA,uBAAON,SAAQa,mBAAS;;AAyT1B;MAEA,WAAe9H"}