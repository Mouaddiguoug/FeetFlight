{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { hash, compare } from 'bcrypt';\nimport { sign, verify } from 'jsonwebtoken';\nimport { SECRET_KEY } from '@config';\nimport { HttpException } from '@exceptions/HttpException';\nimport { User } from '@interfaces/users.interface';\nimport userModel from '@models/users.model';\nimport { isEmpty } from '@utils/util';\nimport { initializeDbConnection, stripe } from '@/app';\nimport { RolesEnum } from '../enums/RolesEnums';\nimport uid from 'uid';\nimport moment from 'moment';\nimport { transporter } from '@/app';\n\nclass AuthService {\n  public users = userModel;\n\n  public async signup(userData) {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n    \n    const signupSession = initializeDbConnection().session({ database: 'neo4j' });\n    const createWalletSession = initializeDbConnection().session({ database: 'neo4j' });\n\n    const email = userData.data.email;\n    try {\n      const findUser = await signupSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length > 0) return { message: `This email ${userData.data.email} already exists` };\n      const hashedPassword = await hash(userData.data.password, 10);\n      if (!userData.data.role || !userData.data.name || !userData.data.userName || !userData.data.password) return { message: 'mlissing data' };\n      switch (userData.data.role) {\n        case RolesEnum.SELLER:\n          if (!userData.data.phone || userData.data.plans.length == 0) return { message: 'data missing' };\n\n          const sellerCustomer = await stripe.customers.create({\n            name: userData.data.name,\n            email: email,\n            balance: 0,\n          });\n\n          const seller = await stripe.accounts.create({\n            email: userData.data.email,\n            type: 'express',\n          });\n\n          const createUserSeller = await signupSession.executeWrite(tx =>\n            tx.run(\n              'create (u:user {id: $userId, name: $name, email: $email, userName: $userName, avatar: \"\", password: $password, createdAt: $createdAt, confirmed: false, verified: false, desactivated: false, phone: $phone, followers: $followers, followings: $followings})-[r: IS_A]->(s:seller {id: $sellerId, verified: $verified}) create (d:deviceToken {token: $token})<-[:logged_in_with]-(u) return u, s',\n              {\n                userId: sellerCustomer.id,\n                followers: 0,\n                followings: 0,\n                buyerId: uid.uid(40),\n                token: userData.data.deviceToken,\n                createdAt: moment().format('MMMM DD, YYYY'),\n                email: email,\n                userName: userData.data.userName,\n                name: userData.data.name,\n                password: hashedPassword,\n                sellerId: seller.id,\n                verified: false,\n                phone: userData.data.phone,\n              },\n            ),\n          );\n\n          await createWalletSession.executeWrite(tx =>\n            tx.run('match (s:seller {id: $sellerId}) create (s)-[:HAS_A]->(:wallet {id: $walletId, amount: 0.0})', {\n              sellerId: createUserSeller.records.map(record => record.get('s').properties.id)[0],\n              walletId: uid.uid(40),\n            }),\n          );\n\n          userData.data.plans.map(async (plan: any) => {\n            const createPlansSession = initializeDbConnection().session({ database: 'neo4j' });\n            try {\n              const stripeCreatedPlan = await stripe.products.create({\n                name: plan.name,\n              });\n              const stripeCreatedPrice = await stripe.prices.create({\n                currency: \"EUR\",\n                product: stripeCreatedPlan.id,\n                recurring: {\n                  interval: \"month\",\n                  interval_count: 1,\n                },\n                unit_amount: plan.price * 100\n              });\n\n              await createPlansSession.executeWrite(tx =>\n                tx.run('match (s:seller {id: $sellerId}) create (s)-[:HAS_A]->(:plan {id: $planId, name: $name, price: $price})', {\n                  sellerId: createUserSeller.records.map(record => record.get('s').properties.id)[0],\n                  planId: stripeCreatedPrice.id,\n                  name: plan.name,\n                  price: plan.price,\n                }),\n              );\n            } catch (error) {\n              console.log(error);\n            } finally {\n              createPlansSession.close();\n            }\n          });\n\n          const sellerToken = this.createToken(process.env.EMAIL_SECRET, createUserSeller.records.map(record => record.get('u').properties.id)[0]);\n\n          this.sendVerificationEmail(email, userData.data.userName, sellerToken.token, 'selling');\n          return { tokenData: sellerToken, data: createUserSeller.records.map(record => record.get('u').properties)[0], role: RolesEnum.SELLER };\n          break;\n        case RolesEnum.BUYER:\n          const buyer = await stripe.customers.create({\n            name: userData.data.name,\n            email: email,\n            balance: 0,\n          });\n\n          const createdUserBuyer = await signupSession.executeWrite(tx =>\n            tx.run(\n              'create (u:user {id: $userId, avatar: \"\", name: $name, email: $email, userName: $userName, password: $password, createdAt: $createdAt, confirmed: false})-[r: IS_A]->(b:buyer {id: $buyerId}) create (d:deviceToken {token: $token})<-[:logged_in_with]-(u) return u',\n              {\n                userId: buyer.id,\n                buyerId: uid.uid(40),\n                token: userData.data.deviceToken,\n                createdAt: moment().format('MMMM DD, YYYY'),\n                email: email,\n                userName: userData.data.userName,\n                name: userData.data.name,\n                password: hashedPassword,\n              },\n            ),\n          );\n\n          const buyerToken = this.createToken(process.env.EMAIL_SECRET, createdUserBuyer.records.map(record => record.get('u').properties.id)[0]);\n          this.sendVerificationEmail(email, userData.data.userName, buyerToken.token, 'finding');\n\n          return { tokenData: buyerToken, data: createdUserBuyer.records.map(record => record.get('u').properties)[0], role: RolesEnum.BUYER };\n          break;\n      }\n    } catch (error) {\n      console.log(error);\n    } finally {\n      await signupSession.close();\n      await createWalletSession.close();\n    }\n  }\n\n  public async sendVerificationEmail(email: string, userName: string, token: string, role: string) {\n    try {\n      const mailOptions = {\n        template: 'verifying_email',\n        from: process.env.USER,\n        to: email,\n        subject: 'Verifying Email',\n        context: {\n          userName: userName,\n          token: token,\n          domain: process.env.DOMAIN,\n          role: role,\n        },\n      };\n\n      transporter.sendMail(mailOptions, (error: any, data: any) => {\n        if (error) console.log(error);\n        if (!error) console.log('sent');\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public async resendVerificationEmail(email: string) {\n    const getUserByEmailSession = initializeDbConnection().session();\n\n    try {\n      const user = await getUserByEmailSession.executeRead(tx => tx.run(\"match (u:user {email: $email})-[:IS_A]->(b:buyer) return u, b\", {\n        email: email\n      }));\n  \n      const tokenData = this.createToken(process.env.EMAIL_SECRET, user.records.map(record => record.get('u').properties.id)[0])\n  \n\n      const mailOptions = {\n        template: 'verifying_email',\n        from: process.env.USER,\n        to: email,\n        subject: 'Verifying Email',\n        context: {\n          userName: user.records.map(record => record.get('u').properties.userName)[0],\n          token: tokenData.token,\n          domain: process.env.DOMAIN,\n          role: user.records.map(record => record.get('b').properties).length == 0 ? \"Seller\" : \"Buyer\",\n        },\n      };\n\n      transporter.sendMail(mailOptions, (error: any, data: any) => {\n        if (error) console.log(error);\n        if (!error) console.log('sent');\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public async changePassword(email: String, userData: any) {\n    const checkUserSession = initializeDbConnection().session();\n    const changePasswordSession = initializeDbConnection().session();\n    try {\n\n      const findUser = await checkUserSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length == 0) return { message: `old password is incorrect` };\n\n      const password = findUser.records.map(record => record.get('u').properties.password)[0];\n      const isPasswordMatching = await compare(userData.data.oldPassword, password);\n      if (!isPasswordMatching) return { message: 'old password is incorrect' };\n      const hashedPassword = await hash(userData.data.newPassword, 10);\n      const changedPassword = await changePasswordSession.executeWrite(tx =>\n        tx.run('match (u {email: $email}) set u.password = $newPassword return u', {\n          email: email,\n          newPassword: hashedPassword,\n        }),\n      );\n\n      return changedPassword.records.map(record => record.get('u').properties)[0];\n    } catch (error) {\n      console.log(error);\n    } finally {\n      changePasswordSession.close();\n    }\n  }\n\n  public async login(userData) {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n    const loginSession = initializeDbConnection().session({ database: 'neo4j' });\n\n    try {\n      const email = userData.data.email;\n\n      const findUser = await loginSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length == 0) return { message: `password or email is incorrect` };\n\n      const password = findUser.records.map(record => record.get('u').properties.password)[0];\n      const isPasswordMatching = await compare(userData.data.password, password);\n      const userId = findUser.records.map(record => record.get('u').properties.id)[0];\n      const deviceToken = userData.data.deviceToken;\n\n      if (!isPasswordMatching) return { message: 'password or email is incorrect' };\n\n      const tokenData = this.createToken(\n        process.env.SECRET_KEY,\n        userId,\n      );\n\n      const role = await loginSession.executeRead(tx =>\n        tx.run('match (u:user {id: $id})-[:IS_A]-(r:seller) return r', { id: userId }),\n      );\n      \n      await loginSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $id})-[:logged_in_with]->(d:deviceToken) set d.token = $token', { id: userId, token: deviceToken }),\n      );\n\n      return { tokenData, data: findUser.records.map(record => record.get('u').properties)[0], role: role.records.length == 0 ? 'Buyer' : 'Seller' };\n    } catch (error) {\n      console.log(error);\n    } finally {\n      loginSession.close();\n    }\n  }  \n  \n\n  public async refreshToken(id: string) {\n\n    if (!id) return { message: 'missing token' };\n    const refreshSession = initializeDbConnection().session({ database: 'neo4j' });\n    try {\n      const tokenData = this.createRefreshToken(id);\n\n      return { tokenData };\n    } catch (error) {\n      console.log(error);\n    } finally {\n      refreshSession.close();\n    }\n  }\n\n  public async logout(userData: User): Promise<User> {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n\n    const findUser: User = this.users.find(user => user.email === userData.email && user.password === userData.password);\n    if (!findUser) throw new HttpException(409, \"User doesn't exist\");\n\n    return findUser;\n  }\n\n  public createToken(secret: string, data: any) {\n    try {\n      const dataStoredInToken = { id: data };\n      const secretKey: string = secret;\n      const expiresAt: string = '280s';\n      const expiresIn: Date = new Date();\n      console.log(expiresIn);\n      expiresIn.setTime(expiresIn.getTime() + 60000);\n\n      console.log(expiresIn);\n\n\n      return { token: sign(dataStoredInToken, secretKey, { expiresIn: expiresAt }), expiresIn: moment(expiresIn).format(\"YYYY-MM-DD HH:mm:ss.ms\") };\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public createRefreshToken(data) {\n    try {\n      const dataStoredInToken = { id: data, refresh: true };\n\n      const secretKey: string = SECRET_KEY;\n      const expiresAt: string = '280s';\n      const expiresIn: Date = new Date();\n      expiresIn.setTime(expiresIn.getTime() + 60);\n\n      return { token: sign(dataStoredInToken, secretKey, { expiresIn: expiresAt }), expiresIn: moment(expiresIn).format(\"YYYY-MM-DD hh:mm:ss.ms\") };\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public createCookie(tokenData): string {\n    return `Authorization=${tokenData.token}; HttpOnly; Max-Age=${tokenData.expiresIn};`;\n  }\n}\n\nexport default AuthService;\n"],"names":["AuthService","signup","userData","isEmpty","HttpException","signupSession","initializeDbConnection","session","database","createWalletSession","email","data","findUser","executeRead","tx","run","records","length","message","hashedPassword","hash","password","role","name","userName","RolesEnum","SELLER","phone","plans","sellerCustomer","stripe","customers","create","balance","seller","accounts","type","createUserSeller","executeWrite","userId","id","followers","followings","buyerId","uid","token","deviceToken","createdAt","moment","format","sellerId","verified","map","record","get","properties","walletId","plan","createPlansSession","stripeCreatedPlan","products","stripeCreatedPrice","prices","currency","product","recurring","interval","interval_count","unit_amount","price","planId","error","console","log","close","sellerToken","createToken","process","env","EMAIL_SECRET","sendVerificationEmail","tokenData","BUYER","buyer","createdUserBuyer","buyerToken","mailOptions","template","from","USER","to","subject","context","domain","DOMAIN","transporter","sendMail","resendVerificationEmail","getUserByEmailSession","user","changePassword","checkUserSession","changePasswordSession","isPasswordMatching","compare","oldPassword","newPassword","changedPassword","login","loginSession","SECRET_KEY","refreshToken","refreshSession","createRefreshToken","logout","users","find","secret","dataStoredInToken","secretKey","expiresAt","expiresIn","Date","setTime","getTime","sign","refresh","createCookie","userModel"],"mappings":"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"}