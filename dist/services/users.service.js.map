{"version":3,"sources":["../../src/services/users.service.ts"],"sourcesContent":["import { hash } from 'bcrypt';\nimport { HttpException } from '@exceptions/HttpException';\nimport { User } from '@interfaces/users.interface';\nimport { writeFile } from 'node:fs';\nimport { Buffer } from 'node:buffer';\nimport { isEmpty } from '@utils/util';\nimport otpGenerator from \"otp-generator\";\nimport crypto from \"crypto\";\nimport { transporter } from '@/app';\nimport { initializeDbConnection, stripe } from '@/app';\nimport { verify } from 'jsonwebtoken';\nimport path from 'node:path';\nimport OpenAi from 'openai';\nimport AuthService from './auth.service';\n\nclass UserService {\n  public prices = [];\n  public authService = new AuthService();\n\n  public async findUserById(userId) {\n    const getUserSession = initializeDbConnection().session();\n    try {\n      const result = await getUserSession.executeRead(tx =>\n        tx.run('match (u:user {id: $userId}) return u', {\n          userId: userId,\n        }),\n      );\n\n      if (result.records.length == 0) throw new HttpException(409, \"User doesn't exist\");\n\n      return result.records.map(record => record.get('u').properties)[0];\n    } catch (error) {\n      console.log(error);\n    } finally {\n      getUserSession.close();\n    }\n  }\n\n  public async generateAiPictures(color: String, category: String) {\n    const getUserSession = initializeDbConnection().session();\n    try {\n\n      const openai = new OpenAi({\n        apiKey: process.env.OPENAI_API_KEY,\n      });\n\n      const result = await openai.images.generate({\n        prompt: `attractive feet with ${color} nailpolish and ${category}`,\n        n: 5,\n        size: \"256x256\",\n      })\n\n      return result.data\n    } catch (error) {\n      console.log(error);\n    } finally {\n      getUserSession.close();\n    }\n  }\n\n  public async changePassword(email, userData) {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n    const hashedPassword = await hash(userData.data.password, 10);\n    const changePasswordSession = initializeDbConnection().session();\n    try {\n      const updatedUser = await changePasswordSession.executeWrite(tx =>\n        tx.run('match (u:user {email: $email}) set u.password: $password return u', {\n          email: email,\n          password: hashedPassword,\n        }),\n      );\n      if (!updatedUser.records.map(record => record.get('u').properties)) throw new HttpException(409, \"User doesn't exist\");\n      return updatedUser.records.map(record => record.get('u').properties);\n    } catch (error) {\n      console.log(error);\n    } finally {\n      changePasswordSession.close();\n    }\n  }\n\n  public async emailConfirming(token) {\n    const confirmEmailSession = initializeDbConnection().session();\n    try {\n      const tokenData: any = verify(token, process.env.EMAIL_SECRET);\n\n      console.log(tokenData.id);\n\n      const checkConfirmation = await confirmEmailSession.executeRead(tx =>\n        tx.run('match (u:user {id: $userId}) return u', {\n          userId: tokenData.id,\n        }),\n      );\n\n      if (checkConfirmation.records.map(record => record.get('u').properties.confirmed)[0]) return 'this account is already confirmed';\n\n      const confirmed = await confirmEmailSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId}) set u.confirmed = true return u', {\n          userId: tokenData.id,\n        }),\n      );\n\n      return confirmed.records.map(record => record.get('u').properties.confirmed)[0];\n    } catch (error) {\n      console.log(error);\n    } finally {\n      confirmEmailSession.close();\n    }\n  }\n\n  public async updateUser(userId: string, userData: any): Promise<User[]> {\n    const updateUserSession = initializeDbConnection().session();\n    try {\n      const existUser = await this.findUserById(userId);\n\n      const updatedUser = await updateUserSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId}) set u.name = $name, u.userName = $userName return u', {\n          userId: userId,\n          name: userData.data.name ? userData.data.name : existUser.name,\n          userName: userData.data.userName ? userData.data.userName : existUser.userName,\n        }),\n      );\n\n      return updatedUser.records.map(record => record.get('u').properties)[0];\n    } catch (error) {\n      console.log(error);\n    } finally {\n      updateUserSession.close();\n    }\n  }\n\n  public async buyPosts(userId: string, saleData: any) {\n    try {\n      const pricesPromises = await saleData.data.posts.map(post => {\n        return this.checkForSale(userId, post.id).then(exists => {\n          if (exists) return null;\n          return stripe.prices\n            .list({\n              product: post.id,\n            })\n            .then(price => {\n              return { price: price.data[0].id, quantity: 1 };\n            });\n        });\n      });\n\n      const prices = await Promise.all(pricesPromises);\n\n      if (prices.filter(price => price != null).length == 0) return { message: 'all posts selected have already been bought by this user' };\n\n      const sellersPromises = await saleData.data.posts.map(post => {\n        return stripe.products.retrieve(post.id).then(product => {\n          return stripe.prices\n            .list({\n              product: post.id,\n            })\n            .then(price => {\n              return { sellerId: product.metadata.sellerId, productId: post.id, amount: price.data[0].unit_amount };\n            });\n        });\n      });\n\n      const sellers = await Promise.all(sellersPromises);\n\n      const session = await stripe.checkout.sessions.create({\n        success_url: 'https://example.com/success',\n        line_items: prices.filter(price => price != null),\n        mode: 'payment',\n        customer: userId,\n        metadata: {\n          sellersIds: sellers\n            .map(record => {\n              return `sellerId:${record.sellerId}.postId:${record.productId}.amount:${record.amount * 0.01}`;\n            })\n            .toString(),\n        },\n      });\n\n      return session.url;\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public getSellersByPostId = async (postId: string) => {\n    const getSellersByPostIdSession = initializeDbConnection().session();\n    try {\n      const sellers = await getSellersByPostIdSession.executeWrite(tx =>\n        tx.run('match (p:post {id: $postId})-[:HAS_A]-(s:seller) return s', {\n          postId: postId,\n        }),\n      );\n      return sellers.records.map(record => record.get('s').properties);\n    } catch (error) {\n      console.log(error);\n    } finally {\n      getSellersByPostIdSession.close();\n    }\n  };\n\n  public generateOtp = async (email: string) => {\n    try {\n      const otp = otpGenerator.generate(4, {\n        digits: true,\n        specialChars: false,\n        lowerCaseAlphabets: false,\n        upperCaseAlphabets: false\n      });\n\n      const timeLeft = 2 * 60 * 1000;\n      const expiresIn = Date.now() + timeLeft;\n      const data = `${email}.${otp}.${expiresIn}`;\n      const hash = crypto.createHmac(\"sha256\", process.env.SECRET_KEY).update(data).digest(\"hex\");\n      const secondLayer = `${hash}.${expiresIn}`;\n\n\n      const to = email;\n\n      const mailOptions = {\n        html: `<div<h1>Feetflight</h1><br><br><h3>Hello again</h3><br><p>We have received a request to change the password associated with your account. As part of our security measures, we have generated an OTP to verify your identity for this action.</p><br><p>Your OTP is: ${otp}</p><br><p>Please ensure that you use the OTP within the next 2 minutes.</p><br><p>Best regards,</p><br><p>Feetflight,</p></div>`,\n        from: process.env.USER,\n        to: to,\n        subject: 'otp Verification Email',\n        context: {\n          otp: otp,\n        },\n      };\n\n      transporter.sendMail(mailOptions, (error: any, data: any) => {\n        if (error) console.log(error);\n        if (!error) console.log('sent');\n      });\n\n      return secondLayer;\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  public verifyOtp = async (otpSettings: any, email: string) => {\n    try {\n      const getUserByEmailSession = initializeDbConnection().session();\n      const [hashedValue, expiresIn] = otpSettings.hash.split(\".\");\n\n      let now = Date.now();\n\n      if (now > parseInt(expiresIn)) return { \"message\": \"otp was expired\" };\n\n      const data = `${email}.${otpSettings.otp}.${expiresIn}`;\n      const hash = crypto.createHmac(\"sha256\", process.env.SECRET_KEY).update(data).digest(\"hex\");\n\n      const secondLayer = `${hash}.${expiresIn}`;\n\n      if (hash != hashedValue) return { message: \"Invalid otp\" };\n\n      const user = await getUserByEmailSession.executeRead(tx => tx.run(\"match (u:user {email: $email})-[:IS_A]->(b:buyer) return u, b\", {\n        email: email\n      }));\n\n      const tokenData = this.authService.createToken(process.env.EMAIL_SECRET, user.records.map(record => record.get('u').properties.id)[0])\n\n      return { message: \"success\", tokenData, data: user.records.map(record => record.get('u').properties)[0], role: user.records.map(record => record.get('b').properties).length == 0 ? \"Seller\" : \"Buyer\" }\n    } catch (error) {\n      console.log(error);\n\n    }\n\n  }\n\n  public buyPost = async (postId: string, userId: string, sellerId: string, amount: number) => {\n    const buyPostSession = initializeDbConnection().session();\n    try {\n      await buyPostSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId}), (p:post {id: $postId}) create (u)-[bought:BOUGHT_A]->(p) return bought', {\n          userId: userId,\n          postId: postId,\n        }),\n      );\n    } catch (error) {\n      console.log(error);\n    } finally {\n      buyPostSession.close();\n    }\n  };\n\n  public subscribe = async (userId: string, subscriptionData: any) => {\n\n    const getSellerIdSession = initializeDbConnection().session();\n\n    try {\n\n      const seller = await getSellerIdSession.executeWrite(tx =>\n        tx.run('match (user {id: $userId})-[:IS_A]-(s:seller) return s', {\n          userId: subscriptionData.data.sellerId,\n        }),\n      );\n\n      const sellerId = seller.records.map(record => record.get(\"s\").properties.id)[0];\n\n      if (await this.checkForSubscription(userId, sellerId)) return { message: 'Already subscribed' };\n\n      const session = await stripe.checkout.sessions.create({\n        success_url: 'https://example.com/success',\n        line_items: [{ price: subscriptionData.data.subscriptionPlanId, quantity: 1 }],\n        mode: 'subscription',\n        currency: \"EUR\",\n        customer: userId,\n        metadata: {\n          sellerId: sellerId,\n          subscriptionPlanTitle: subscriptionData.data.subscriptionPlanTitle,\n          subscriptionPlanPrice: subscriptionData.data.subscriptionPlanPrice,\n        },\n      });\n\n      return session;\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  public createSubscriptioninDb = async (userId: string, sellerId: string, subscriptionPlanTitle: string, subscriptionPlanPrice: number) => {\n    const subscribeSession = initializeDbConnection().session();\n    try {\n      if (await this.checkForSubscription(userId, sellerId)) return { message: 'Already subscribed' };\n\n      await subscribeSession.executeWrite(tx => {\n        tx.run(\n          'match (u:user {id: $userId}), (s:seller {id: $sellerId})<-[:IS_A]-(user:user) create (u)-[:SUBSCRIBED_TO {subscriptionPlanTitle: $subscriptionPlanTitle, subscriptionPlanPrice: $subscriptionPlanPrice}]->(s) set user.followers = user.followers + 1 set u.followings = u.followings + 1 return s',\n          {\n            userId: userId,\n            sellerId: sellerId,\n            subscriptionPlanTitle: subscriptionPlanTitle,\n            subscriptionPlanPrice: subscriptionPlanPrice,\n          },\n        );\n      });\n\n    } catch (error) {\n      console.log(error);\n    } finally {\n      subscribeSession.close();\n    }\n  };\n\n  public cancelSubscription = async (userId: string, sellerId: string) => {\n\n    const cancelSubscriptionSession = initializeDbConnection().session();\n    try {\n      if (!(await this.checkForSubscription(userId, sellerId))) return { message: 'no subscription' };\n\n      await cancelSubscriptionSession.executeWrite(tx => {\n        tx.run('match (u:user {id: $userId})-[sub:SUBSCRIBED_TO]->(s:seller {id: $sellerId}) detach delete sub', {\n          userId: userId,\n          sellerId: sellerId,\n        });\n      });\n      return { message: 'subscription was canceled successfuly' };\n    } catch (error) {\n      console.log(error);\n    } finally {\n      cancelSubscriptionSession.close();\n    }\n  };\n\n  public checkForSale = async (userId: string, postId: string) => {\n    const checkForExistingRelationship = initializeDbConnection().session();\n    try {\n      const saleAlreadyExists = await checkForExistingRelationship.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId})-[bought:BOUGHT_A]->(p:post {id: $postId}) return bought', {\n          userId: userId,\n          postId: postId,\n        }),\n      );\n\n\n      return saleAlreadyExists.records.map(record => record.get('bought')).length > 0 ? true : false;\n    } catch (error) {\n      console.log(error);\n    } finally {\n      checkForExistingRelationship.close();\n    }\n  };\n\n  public getSellerPlans = async (userId: string) => {\n    const getSellerPlansSession = initializeDbConnection().session();\n    try {\n      const sellerPlan = await getSellerPlansSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId})-[:IS_A]-(seller)-[:HAS_A]-(plan:plan) return plan', {\n          userId: userId,\n        }),\n      );\n\n      return sellerPlan.records.map(record => record.get('plan').properties);\n    } catch (error) {\n      console.log(error);\n    } finally {\n      getSellerPlansSession.close();\n    }\n  };\n\n  public checkForSubscription = async (userId: string, sellerId: string) => {\n    const checkForSubscriptionSession = initializeDbConnection().session();\n    try {\n      const subscriptionAlreadyExist = await checkForSubscriptionSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId})-[subscribed:SUBSCRIBED_TO]->(s:seller {id: $sellerId}) return subscribed', {\n          userId: userId,\n          sellerId: sellerId,\n        }),\n      );\n\n      return subscriptionAlreadyExist.records.map(record => record.get('subscribed')).length > 0 ? true : false;;\n    } catch (error) {\n      console.log(error);\n    } finally {\n      checkForSubscriptionSession.close();\n    }\n  };\n\n  public checkForSubscriptionbyUserId = async (userId: string, postId: string, plan: string) => {\n    const checkForSubscriptionSession = initializeDbConnection().session();\n    try {\n\n      const subscriptionAlreadyExist = await checkForSubscriptionSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId})-[subscribed:SUBSCRIBED_TO {subscriptionPlanTitle: $plan}]->(s:seller)-[:HAS_A]->(p:post {id: $postId}) return subscribed', {\n          userId: userId,\n          postId: postId,\n          plan: plan\n        }),\n      );\n\n\n      return subscriptionAlreadyExist.records.map(record => record.get('subscribed')).length > 0 ? true : false;\n    } catch (error) {\n      console.log(error);\n    } finally {\n      checkForSubscriptionSession.close();\n    }\n  };\n\n\n  public uploadAvatar = async (avatarData: any, userId: string) => {\n    try {\n      /* aws.config.update({\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n        region: 'us-east-2',\n      });\n      const filecontent = Buffer.from(avatarData.buffer, 'binary');\n      const s3 = new aws.S3();\n\n      const params = {\n        Bucket: process.env.AWS_BUCKET_NAME,\n        Key: `${avatarData.fieldname}avatar${userId}.${avatarData.mimetype.split('/')[1]}`,\n        Body: filecontent,\n      };\n\n      s3.upload(params, (err, data) => {\n        if (err) return console.log(err);\n        this.uploadAvatarToDb(data.Location, userId);\n      }); */\n\n      const filecontent = Buffer.from(avatarData.buffer, 'binary');\n\n      console.log(filecontent);\n\n\n      writeFile(\n        path.join(__dirname, '../../public/files/avatars', `avatar${userId}.${avatarData.mimetype.split(\"/\")[1]}`),\n        filecontent,\n        async err => {\n          if (err) return console.log(err);\n          await this.uploadAvatarToDb(`/public/files/avatars/avatar${userId}.${avatarData.mimetype.split(\"/\")[1]}`, userId);\n        },\n      );\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  public uploadAvatarToDb = async (location: string, userId: string) => {\n    const uploadAvatarToDbSession = initializeDbConnection().session();\n    try {\n      await uploadAvatarToDbSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId}) set u.avatar = $avatar', {\n          userId: userId,\n          avatar: location,\n        }),\n      );\n    } catch (error) {\n      console.log(error);\n    } finally {\n      uploadAvatarToDbSession.close();\n    }\n  };\n\n  public async uploadDeviceToken(userId: string, token: string): Promise<void> {\n    const uploadDeviceTokenSession = initializeDbConnection().session();\n    try {\n      await uploadDeviceTokenSession.executeWrite(tx =>\n        tx.run('match (u:user {id: $userId}) create (u)-[:GOT_DEVICE]->(:device {token: $token})', {\n          userId: userId,\n          token: token,\n        }),\n      );\n    } catch (error) {\n      console.log(error);\n    } finally {\n      uploadDeviceTokenSession.close();\n    }\n  };\n\n  public async desactivateUser(userId: number): Promise<User[]> {\n    const desactivateUserSession = initializeDbConnection().session();\n    try {\n      const desactivatedUser = await desactivateUserSession.executeWrite(tx => tx.run('match (u:user {id: $userId}) set u.desactivated = true'));\n      return desactivatedUser.records.map(record => record.get('u').properties)[0];\n    } catch (error) {\n      console.log(error);\n    }\n  }\n}\n\nexport default UserService;\n"],"names":["UserService","findUserById","userId","getUserSession","initializeDbConnection","session","result","executeRead","tx","run","records","length","HttpException","map","record","get","properties","error","console","log","close","generateAiPictures","color","category","openai","OpenAi","apiKey","process","env","OPENAI_API_KEY","images","generate","prompt","n","size","data","changePassword","email","userData","isEmpty","hashedPassword","hash","password","changePasswordSession","updatedUser","executeWrite","emailConfirming","token","confirmEmailSession","tokenData","verify","EMAIL_SECRET","id","checkConfirmation","confirmed","updateUser","updateUserSession","existUser","name","userName","buyPosts","saleData","pricesPromises","posts","post","checkForSale","then","exists","stripe","prices","list","product","price","quantity","Promise","all","filter","message","sellersPromises","products","retrieve","sellerId","metadata","productId","amount","unit_amount","sellers","checkout","sessions","create","success_url","line_items","mode","customer","sellersIds","toString","url","uploadDeviceToken","uploadDeviceTokenSession","desactivateUser","desactivateUserSession","desactivatedUser","authService","AuthService","getSellersByPostId","postId","getSellersByPostIdSession","generateOtp","otp","otpGenerator","digits","specialChars","lowerCaseAlphabets","upperCaseAlphabets","timeLeft","expiresIn","Date","now","crypto","createHmac","SECRET_KEY","update","digest","secondLayer","to","mailOptions","html","from","USER","subject","context","transporter","sendMail","verifyOtp","otpSettings","getUserByEmailSession","hashedValue","split","parseInt","user","createToken","role","buyPost","buyPostSession","subscribe","subscriptionData","getSellerIdSession","seller","checkForSubscription","subscriptionPlanId","currency","subscriptionPlanTitle","subscriptionPlanPrice","createSubscriptioninDb","subscribeSession","cancelSubscription","cancelSubscriptionSession","checkForExistingRelationship","saleAlreadyExists","getSellerPlans","getSellerPlansSession","sellerPlan","checkForSubscriptionSession","subscriptionAlreadyExist","checkForSubscriptionbyUserId","plan","uploadAvatar","avatarData","filecontent","Buffer","buffer","writeFile","path","join","__dirname","mimetype","err","uploadAvatarToDb","location","uploadAvatarToDbSession","avatar"],"mappings":"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"}